# UPDATES FOR PROMPT_RED_CODE.yaml
# This file contains updates for the new command-based seed/cleanup approach

# =================================================================
# SECTION 1: Update step_4_generate_seed_data
# =================================================================

step_4_generate_seed_data:
  description: "Generate seed data functions for IT/E2E tests using COMMAND-BASED seeding strategy"
  prompt: |
    CRITICAL: Understand the COMMAND-BASED seeding strategy (see src/tests/setup/README.md):
    - Tests do NOT seed data themselves
    - Seeding is done via: npm run test:seed <api-name>
    - Cleanup is done via: npm run test:cleanup <api-name>
    - Tests assume data is pre-seeded and only verify logic

    1. Generate seed file: [action-domain].seed.ts

    2. File structure MUST include:

      A. CONSTANTS (export at top):
        - Test IDs: TEST_SOFTWARE_ID, TEST_TENANT_ID, TEST_USER_ID, etc.
        - Credentials: TEST_USER_CREDENTIALS, TEST_USER_WITHOUT_PERMISSION_CREDENTIALS

      B. MAIN FUNCTIONS (for npm run commands):

        **seedAllTestData(dataSource: DataSource): Promise<void>**
        - Called by: npm run test:seed <api-name>
        - Purpose: Seed ALL data (base + domain-specific)
        - Uses transaction: commit on success, rollback on error
        - Calls all seed helper functions in topological order
        - Example:
          ```typescript
          export async function seedAllTestData(dataSource: DataSource): Promise<void> {
            const queryRunner = dataSource.createQueryRunner();
            await queryRunner.connect();
            await queryRunner.startTransaction();

            try {
              // Seed base data (users, tenants, workspaces, roles, permissions)
              await seedSoftwares(queryRunner);
              await seedTenants(queryRunner);
              await seedUsers(queryRunner);
              await seedWorkspaces(queryRunner);
              await seedEmployees(queryRunner);
              await seedRoles(queryRunner);
              await seedPermissions(queryRunner);
              await seedRolePermissions(queryRunner);
              await seedRoleWorkspaces(queryRunner);

              // Seed API-specific data (e.g., product categories)
              await seed<DomainPlural>TestData(queryRunner);

              await queryRunner.commitTransaction();
            } catch (error) {
              await queryRunner.rollbackTransaction();
              throw error;
            } finally {
              await queryRunner.release();
            }
          }
          ```

        **cleanupAllTestData(dataSource: DataSource): Promise<void>**
        - Called by: npm run test:cleanup <api-name>
        - Purpose: Delete ALL test data for this API
        - Uses DELETE queries (not TRUNCATE) with specific IDs
        - Deletes in REVERSE order to avoid FK constraints
        - Example:
          ```typescript
          export async function cleanupAllTestData(dataSource: DataSource): Promise<void> {
            const queryRunner = dataSource.createQueryRunner();
            await queryRunner.connect();

            try {
              await queryRunner.query('SET FOREIGN_KEY_CHECKS = 0');

              // Cleanup in reverse order to avoid FK constraints
              await queryRunner.query('DELETE FROM <domain_table> WHERE tenant_id = ?', [TEST_TENANT_ID]);
              await queryRunner.query('DELETE FROM role_workspaces WHERE workspace_id IN (SELECT id FROM workspaces WHERE tenant_id = ?)', [TEST_TENANT_ID]);
              await queryRunner.query('DELETE FROM role_permissions WHERE role_id IN (SELECT id FROM roles WHERE tenant_id = ?)', [TEST_TENANT_ID]);
              await queryRunner.query('DELETE FROM roles WHERE tenant_id = ?', [TEST_TENANT_ID]);
              await queryRunner.query('DELETE FROM permissions WHERE id = ?', [TEST_PERMISSION_ID]);
              await queryRunner.query('DELETE FROM employees WHERE workspace_id IN (SELECT id FROM workspaces WHERE tenant_id = ?)', [TEST_TENANT_ID]);
              await queryRunner.query('DELETE FROM workspaces WHERE tenant_id = ?', [TEST_TENANT_ID]);
              await queryRunner.query('DELETE FROM users WHERE id IN (?, ?)', [TEST_USER_ID, TEST_USER_WITHOUT_PERMISSION_ID]);
              await queryRunner.query('DELETE FROM tenants WHERE id = ?', [TEST_TENANT_ID]);
              await queryRunner.query('DELETE FROM softwares WHERE id = ?', [TEST_SOFTWARE_ID]);

              await queryRunner.query('SET FOREIGN_KEY_CHECKS = 1');
            } finally {
              await queryRunner.release();
            }
          }
          ```

      C. HELPER FUNCTIONS (internal use):
        - seedSoftwares(queryRunner): Seed software using INSERT IGNORE
        - seedTenants(queryRunner): Seed tenant using ON DUPLICATE KEY UPDATE
        - seedUsers(queryRunner): Seed TWO users (with/without permission)
        - seedWorkspaces(queryRunner): Seed TWO workspaces
        - seedEmployees(queryRunner): Seed TWO employees
        - seedRoles(queryRunner): Seed TWO roles
        - seedPermissions(queryRunner): Seed permission
        - seedRolePermissions(queryRunner): Link role to permission
        - seedRoleWorkspaces(queryRunner): Link roles to workspaces
        - seed<DomainPlural>TestData(queryRunner): Seed domain-specific data

      D. LEGACY FUNCTIONS (optional - for backward compatibility):
        - seedTestData(dataSource): Old approach - can be kept for compatibility
        - cleanup(dataSource): Old cleanup using TRUNCATE ALL

    3. SQL Patterns:
      - softwares: INSERT IGNORE (runs first, required by FK)
      - Other base tables: INSERT ... ON DUPLICATE KEY UPDATE
      - Domain tables: Simple INSERT (in seed<DomainPlural>TestData)

    4. Code Generation Rules:
      - Generate ACTUAL code (not placeholders)
      - Derive columns from db_schema
      - Use exported constants for IDs
      - Include proper error handling
      - Add comments explaining purpose

# =================================================================
# SECTION 2: Update code_templates.seed_data_helper_template
# =================================================================

code_templates:
  seed_data_helper_template:
    description: "Structure for [action-domain].seed.ts - command-based approach"

    critical_instructions: |
      CRITICAL: Generate seed files that work with command-based workflow:
      - npm run test:seed <api-name> → calls seedAllTestData()
      - npm run test:cleanup <api-name> → calls cleanupAllTestData()
      - Tests do NOT call these functions directly

      See: src/tests/setup/README.md for usage documentation

    file_structure:
      1_constants:
        description: "Export ID constants and credentials at top"
        pattern: |
          export const TEST_SOFTWARE_ID = 1;
          export const TEST_TENANT_ID = 100000;
          export const TEST_USER_ID = 100001;
          export const TEST_USER_WITHOUT_PERMISSION_ID = 100002;
          // ... other IDs ...

          export const REQUIRED_PERMISSION_NAME = '<DERIVED_PERMISSION>';

          export const TEST_USER_CREDENTIALS = {
            username: 'user.with.permission',
            password: 'Test@123456',
            softwareId: TEST_SOFTWARE_ID,
          };

          export const TEST_USER_WITHOUT_PERMISSION_CREDENTIALS = {
            username: 'user.without.permission',
            password: 'Test@123456',
            softwareId: TEST_SOFTWARE_ID,
          };

      2_main_functions:
        description: "Main functions for npm run commands"

        seedAllTestData:
          signature: "export async function seedAllTestData(dataSource: DataSource): Promise<void>"
          purpose: "Seed ALL test data (base + domain-specific)"
          called_by: "npm run test:seed <api-name>"
          pattern: |
            // ========================================
            // MAIN FUNCTIONS (for npm run test:seed/cleanup)
            // ========================================

            /**
             * Seed ALL test data for this API (base data + domain data)
             * Called by: npm run test:seed <api-name>
             */
            export async function seedAllTestData(dataSource: DataSource): Promise<void> {
              const queryRunner = dataSource.createQueryRunner();
              await queryRunner.connect();
              await queryRunner.startTransaction();

              try {
                // Seed base data (users, tenants, workspaces, roles, permissions)
                await seedSoftwares(queryRunner);
                await seedTenants(queryRunner);
                await seedUsers(queryRunner);
                await seedWorkspaces(queryRunner);
                await seedEmployees(queryRunner);
                await seedRoles(queryRunner);
                await seedPermissions(queryRunner);
                await seedRolePermissions(queryRunner);
                await seedRoleWorkspaces(queryRunner);

                // Seed API-specific data
                await seed<DomainPlural>TestData(queryRunner);

                await queryRunner.commitTransaction();
              } catch (error) {
                await queryRunner.rollbackTransaction();
                throw error;
              } finally {
                await queryRunner.release();
              }
            }

        cleanupAllTestData:
          signature: "export async function cleanupAllTestData(dataSource: DataSource): Promise<void>"
          purpose: "Cleanup ALL test data for this API"
          called_by: "npm run test:cleanup <api-name>"
          pattern: |
            /**
             * Cleanup ALL test data for this API
             * Called by: npm run test:cleanup <api-name>
             */
            export async function cleanupAllTestData(dataSource: DataSource): Promise<void> {
              const queryRunner = dataSource.createQueryRunner();
              await queryRunner.connect();

              try {
                await queryRunner.query('SET FOREIGN_KEY_CHECKS = 0');

                // Cleanup in reverse order to avoid FK constraints
                await queryRunner.query('DELETE FROM <domain_table> WHERE tenant_id = ?', [TEST_TENANT_ID]);
                await queryRunner.query('DELETE FROM role_workspaces WHERE workspace_id IN (SELECT id FROM workspaces WHERE tenant_id = ?)', [TEST_TENANT_ID]);
                await queryRunner.query('DELETE FROM role_permissions WHERE role_id IN (SELECT id FROM roles WHERE tenant_id = ?)', [TEST_TENANT_ID]);
                await queryRunner.query('DELETE FROM roles WHERE tenant_id = ?', [TEST_TENANT_ID]);
                await queryRunner.query('DELETE FROM permissions WHERE id = ?', [TEST_PERMISSION_ID]);
                await queryRunner.query('DELETE FROM employees WHERE workspace_id IN (SELECT id FROM workspaces WHERE tenant_id = ?)', [TEST_TENANT_ID]);
                await queryRunner.query('DELETE FROM workspaces WHERE tenant_id = ?', [TEST_TENANT_ID]);
                await queryRunner.query('DELETE FROM users WHERE id IN (?, ?)', [TEST_USER_ID, TEST_USER_WITHOUT_PERMISSION_ID]);
                await queryRunner.query('DELETE FROM tenants WHERE id = ?', [TEST_TENANT_ID]);
                await queryRunner.query('DELETE FROM softwares WHERE id = ?', [TEST_SOFTWARE_ID]);

                await queryRunner.query('SET FOREIGN_KEY_CHECKS = 1');
              } finally {
                await queryRunner.release();
              }
            }

      3_helper_functions:
        description: "Individual seed functions for each table"
        pattern: |
          // ========================================
          // HELPER FUNCTIONS (internal use)
          // ========================================

          async function seedSoftwares(queryRunner: QueryRunner) {
            await queryRunner.query(
              'INSERT IGNORE INTO softwares (id, name, created_at, updated_at) VALUES (?, ?, NOW(), NOW())',
              [TEST_SOFTWARE_ID, 'Test Software']
            );
          }

          async function seedTenants(queryRunner: QueryRunner) {
            await queryRunner.query(
              'INSERT INTO tenants (id, name, status, ...) VALUES (?, ?, ?, ...) ON DUPLICATE KEY UPDATE name = VALUES(name)',
              [TEST_TENANT_ID, 'Tenant E2E', 1, ...]
            );
          }

          // ... other seed functions ...

          async function seed<DomainPlural>TestData(queryRunner: QueryRunner) {
            // Seed domain-specific data
            await queryRunner.query(
              'INSERT INTO <domain_table> (id, name, tenant_id, ...) VALUES (?, ?, ?, ...)',
              [TEST_<DOMAIN>_ID, '<test value>', TEST_TENANT_ID, ...]
            );
          }

      4_legacy_functions:
        description: "Optional - for backward compatibility"
        note: "Can be kept if needed, but new code should use main functions"
        pattern: |
          // ========================================
          // LEGACY FUNCTIONS (kept for backward compatibility)
          // ========================================

          export async function seedTestData(dataSource: DataSource) {
            // Old approach - calls seedAllTestData or similar logic
          }

          export async function cleanup(dataSource: DataSource) {
            // Old cleanup using TRUNCATE ALL
          }

# =================================================================
# SECTION 3: Update E2E test template
# =================================================================

code_templates:
  e2e_test_template: |
    import { Test, TestingModule } from '@nestjs/testing';
    import { INestApplication, ValidationPipe } from '@nestjs/common';
    import request from 'supertest';
    import { AppModule } from '../../../../app.module';
    import {
      TEST_<DOMAIN_CONSTANT>_ID,
      TEST_USER_CREDENTIALS,
      TEST_USER_WITHOUT_PERMISSION_CREDENTIALS,
    } from './[action-domain].seed';

    describe('<HTTP_METHOD> /api/v1/<bounded-context>/<resources> E2E', () => {
      let app: INestApplication;
      let accessTokenWithPermission: string;
      let accessTokenWithoutPermission: string;

      beforeAll(async () => {
        // ⚠️ IMPORTANT: Data must be seeded before running tests
        // Run: npm run test:seed <action-domain>

        const moduleFixture: TestingModule = await Test.createTestingModule({
          imports: [AppModule],
        }).compile();

        app = moduleFixture.createNestApplication();
        app.useGlobalPipes(
          new ValidationPipe({
            whitelist: true,
            transform: false,
            forbidUnknownValues: false,
          })
        );
        await app.init();

        // Login user with permission (using pre-seeded data)
        const loginRes = await request(app.getHttpServer())
          .post('/api/v1/auth/login')
          .send({
            username: TEST_USER_CREDENTIALS.username,
            password: TEST_USER_CREDENTIALS.password,
            softwareId: TEST_USER_CREDENTIALS.softwareId,
          });
        expect(loginRes.status).toBeLessThan(400);
        accessTokenWithPermission = loginRes.body?.data?.accessToken || loginRes.body?.accessToken;
        expect(accessTokenWithPermission).toBeDefined();

        // Login user without permission (using pre-seeded data)
        const loginResNoScope = await request(app.getHttpServer())
          .post('/api/v1/auth/login')
          .send({
            username: TEST_USER_WITHOUT_PERMISSION_CREDENTIALS.username,
            password: TEST_USER_WITHOUT_PERMISSION_CREDENTIALS.password,
            softwareId: TEST_USER_WITHOUT_PERMISSION_CREDENTIALS.softwareId,
          });
        expect(loginResNoScope.status).toBeLessThan(400);
        accessTokenWithoutPermission = loginResNoScope.body?.data?.accessToken || loginResNoScope.body?.accessToken;
        expect(accessTokenWithoutPermission).toBeDefined();
      });

      afterAll(async () => {
        // ⚠️ Data cleanup is done via: npm run test:cleanup <action-domain>
        await app.close();
      });

      it('AC_E2E_01: return successful response when user inputs valid data', async () => {
        // Arrange
        const query = {
          field1: value1,
          arrayField: JSON.stringify([value1, value2]), // Arrays must use JSON.stringify for GET
        };

        // Act
        const res = await request(app.getHttpServer())
          .<http_method>('/api/v1/<bounded-context>/<resources>')
          .set('Authorization', `Bearer ${accessTokenWithPermission}`)
          .query(query); // For GET
          // .send(body); // For POST/PUT

        // Assert
        expect(res.status).toBe(200); // AC_E2E_01
        expect(res.body).toHaveProperty('total'); // AC_E2E_01
        // ... other assertions
      });

      it('AC_E2E_05: return error response when Permission is denied', async () => {
        // Arrange
        const query = { ... };

        // Act
        const res = await request(app.getHttpServer())
          .<http_method>('/api/v1/<bounded-context>/<resources>')
          .set('Authorization', `Bearer ${accessTokenWithoutPermission}`) // User without permission
          .query(query);

        // Assert
        expect(res.status).toBe(403); // AC_E2E_05
        expect(res.body.messageKey).toBe('auth_error.forbidden'); // AC_E2E_05
      });
    });

# =================================================================
# SECTION 4: Update Handler IT test template
# =================================================================

code_templates:
  handler_it_template: |
    import { Test, TestingModule } from '@nestjs/testing';
    import { AppModule } from '../../../../app.module';
    import {
      TEST_<DOMAIN_CONSTANT>_ID,
      TEST_TENANT_ID,
    } from './[action-domain].seed';

    describe('<ComponentName>Handler Integration Tests', () => {
      let moduleRef: TestingModule;

      beforeAll(async () => {
        // ⚠️ IMPORTANT: Data must be seeded before running tests
        // Run: npm run test:seed <action-domain>

        moduleRef = await Test.createTestingModule({
          imports: [AppModule],
        }).compile();
      });

      afterAll(async () => {
        // ⚠️ Data cleanup is done via: npm run test:cleanup <action-domain>
        await moduleRef.close();
      });

      it('AC_IT_01: return successful message when valid data is provided', async () => {
        // Arrange
        const { <ComponentName>Handler } = await import('../../../../components/<bounded-context>/application/queries/<component-name>.query-handler');
        const handler = moduleRef.get<any>(<ComponentName>Handler);
        expect(handler).toBeDefined();

        const query = {
          field1: value1,
          field2: value2,
        };

        // Act
        const result = await handler.execute({ ...query, currentUser: { tenantId: TEST_TENANT_ID } });

        // Assert
        expect(result).toBeDefined(); // AC_IT_01
        // ... other assertions
      });
    });

# =================================================================
# SECTION 5: Update Repository IT test template
# =================================================================

code_templates:
  repository_it_template: |
    import { Test, TestingModule } from '@nestjs/testing';
    import { TypeOrmModule } from '@nestjs/typeorm';
    import { ConfigModule } from '@nestjs/config';
    import { <DomainName>QueryRepository } from '../../../../components/<bounded-context>/infrastructure/repositories/<domain-name>-query.repository';
    import { I<DomainName>QueryRepository } from '../../../../components/<bounded-context>/application/repositories/<domain-name>-query.repository';
    import { TEST_TENANT_ID } from './[action-domain].seed';
    import { <DomainName>Model } from '../../../../components/<bounded-context>/infrastructure/entities/<domain-name>.model';

    describe('<DomainName>QueryRepository - Integration Tests', () => {
      let module: TestingModule;
      let repository: I<DomainName>QueryRepository;

      beforeAll(async () => {
        // ⚠️ IMPORTANT: Data must be seeded before running tests
        // Run: npm run test:seed <action-domain>

        module = await Test.createTestingModule({
          imports: [
            ConfigModule.forRoot({ isGlobal: true }),
            TypeOrmModule.forRoot({
              type: 'mariadb',
              host: process.env.DB_HOST || 'localhost',
              port: parseInt(process.env.DB_PORT || '3306'),
              username: process.env.DB_USERNAME || 'root',
              password: process.env.DB_PASSWORD || '',
              database: process.env.DB_DATABASE || 'test_db',
              synchronize: false,
              logging: false,
              entities: [<DomainName>Model],
            }),
            TypeOrmModule.forFeature([<DomainName>Model]),
          ],
          providers: [
            {
              provide: 'I<DomainName>QueryRepository',
              useClass: <DomainName>QueryRepository,
            },
          ],
        }).compile();

        repository = module.get<I<DomainName>QueryRepository>('I<DomainName>QueryRepository');
      });

      afterAll(async () => {
        // ⚠️ Data cleanup is done via: npm run test:cleanup <action-domain>
        await module.close();
      });

      it('AC_Pairwise_01: test case description', async () => {
        // Arrange
        const input = {
          tenantId: TEST_TENANT_ID,
          field1: value1,
          page: 1,
          size: 20,
        };

        // Act
        const models = await repository.findAll(
          input.tenantId,
          input.field1,
          input.page,
          input.size,
        );

        const total = await repository.count(
          input.tenantId,
          input.field1,
        );

        // Assert
        expect(Array.isArray(models)).toBe(true);
        expect(total).toBeGreaterThanOrEqual(0);
        // ... other assertions
      });
    });

# =================================================================
# SECTION 6: Add workflow documentation
# =================================================================

standard_knowledge:
  test_workflow:
    description: "Command-based test workflow"

    workflow_steps:
      1_seed_data:
        command: "npm run test:seed <action-domain>"
        purpose: "Seed all test data for the API"
        example: "npm run test:seed get-list-product-category"

      2_run_tests:
        command: "npm run test:redcode <action-domain>"
        purpose: "Run tests for the API"
        example: "npm run test:redcode get-list-product-category"

      3_cleanup_data:
        command: "npm run test:cleanup <action-domain>"
        purpose: "Cleanup all test data"
        example: "npm run test:cleanup get-list-product-category"

    full_workflow:
      command: "npm run test:seed <api> && npm run test:redcode <api> && npm run test:cleanup <api>"
      description: "Complete workflow: seed → test → cleanup"

    benefits:
      - "Tests are simpler (no seed logic)"
      - "Can seed once, run tests multiple times"
      - "Flexible (seed individual APIs or all at once)"
      - "Easy to debug (run seed/cleanup separately)"

    important_notes:
      - "Tests assume data is pre-seeded"
      - "Tests do NOT call seed functions"
      - "Data is shared between tests (no transaction isolation)"
      - "If test modifies data, re-run seed before next test"
